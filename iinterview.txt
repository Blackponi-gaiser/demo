OSI - ceтевая модель стека сетевых протоколов, которая стандартизирует то, как различные программные и аппаратные компоненты, 
участвуют в сетевой коммутации, должны разделять задачи и взаимодействовать друг с другом.
Физический - 1 и 0
Канальный уровень - передача узла в одном сегменте сети 
Сетевой уровень - определение пути передачи данных
Транспортный уровень - доставка данных tcp, udp(tcp требует подтверждение о получение данных)
Сеансовый уровень -  управление сеансами 
Уровень представления - шифрование и дешифрование данных 
Уровень приложений(приклодной) - взаимодействия сети и пользователя 
TCP/IP - сетевая модель передачи данных, представленных в цифровом виде, которая не привязана к проводной сети.
Прикладной уровень - взаимодействия сети и пользователя
Транспортный уровень - доставка данных tcp, udp
Межсетевой уровень - работа сетевого оборудовавния 
Канальный уровень - подготовка пакетов для отпраки
..............................................................................................
waterfoll - всё происходит по этапно и всё повторяется также (используется там где четкие сроки)
Agile - предназначены для адаптации к изменяющимся потребностям бизнеса во время разработки (более гибкий)
DevOps —  организационное сотрудничество, которое привело к набору лучших практик посредством непрерывной интеграции,
непрерывной доставки и непрерывного тестирования.
DevOps - это методология совместной разработки и операционного управления процессами разработки и выпуска программного
обеспечения. Она объединяет разработчиков (Dev) и операционных специалистов (Ops) для создания автоматизированных и стабильных
 процессов разработки, тестирования, развертывания и управления приложениями.
.............................................................................................
Kubernetes - это открытая платформа для автоматизации развертывания, масштабирования и управления контейнеризированными приложениями. 
1. Под (Pod): Наименьшая и фундаментальная единица в Kubernetes. Под представляет собой группу связанных контейнеров, 
которые работают вместе на одном хосте.
2. Репликационный контроллер (Replication Controller): Отвечает за поддержание заданного количества реплик (инстансов) подов, 
обеспечивая их непрерывную работу.
3. Репликационный набор (ReplicaSet): Эволюция репликационных контроллеров в Kubernetes. 
Он предоставляет более гибкие возможности управления масштабированием и обновлением подов.
4. Деплоймент (Deployment): Позволяет определить и управлять деплойментами приложений. 
Он определяет желаемое состояние приложения и автоматически выравнивает фактическое состояние с заданным.
5. Сервис (Service): Абстракция, предоставляющая постоянное имя и сетевую доступность к одной или нескольким репликам подов. 
Сервисы позволяют подам общаться между собой и с внешними клиентами.
6. Ingress: Конфигурация, которая обеспечивает управление внешним доступом к сервисам внутри кластера Kubernetes. 
Ingress определяет правила маршрутизации и настройки балансировщика нагрузки для обработки входящих запросов.
7. Конфиг-карта (ConfigMap): Используется для хранения конфигурационных данных в виде пар ключ-значение.
8. Таймер (CronJob): Позволяет планировать выполнение задач по расписанию.
Основные команды для работы с Kubernetes:
1. kubectl create: Создает объект Kubernetes из файла YAML.
2. kubectl apply: Применяет изменения в объекте Kubernetes из файла YAML.
3. kubectl get: Отображает информацию о сущностях Kubernetes (например, поды, сервисы, задания).
4. kubectl describe: Предоставляет подробную информацию о сущности Kubernetes.
5. kubectl delete: Удаляет сущность Kubernetes.
6. kubectl logs: Просматривает журналы контейнера в поде Kubernetes.
7. kubectl exec: Запускает команду в контейнере в поде Kubernetes.
8. kubectl port-forward: Направляет сетевые порты локального компьютера на поды Kubernetes.
9. kubectl scale: Изменяет масштаб набора реплик подов.
10. kubectl rollout: Управляет процессом развертывания новой версии приложения.
11. kubectl expose: Создает новый сервис для пода, чтобы было возможно обращаться к нему извне кластера.
12. kubectl cluster-info: Выводит информацию о кластере Kubernetes.
13. kubectl config: Управляет конфигурацией kubectl, включая контексты и учетные данные.
14. kubectl top: Выводит информацию о ресурсах, используемых подами и узлами.
15. kubectl edit: Редактирует сущность Kubernetes в интерактивном режиме. 
Секреты в Kubernetes используются для безопасного хранения и управления конфиденциальными данными, такими как пароли, токены, 
ключи шифрования и другая чувствительная информация, которая не должна быть доступна широкой аудитории.
..............................................................................................
Ограницение ресурсов в докер:
Namespace
Set group
CMD команда
enterpoint можно передовать как аргумент 
..............................................................................................
HAProxy - это открытое программное обеспечение для балансировки нагрузки и проксирования HTTP-трафика.
frontend kubernetes-frontend
    bind *:6443    Входяшие соединение 
    mode tcp       В режиме tcp все пакеты проксируются без анализа содержимого 
    option tcplog
    default_backend kubernetes-backend
backend kubernetes-backend
    mode tcp
    option tcp-check
    balance roundrobin равномерное распределение нагрузки
    server master-node1 109.123.154.185:6443 check здесь указыаеться между скальки серверами
...................................................................................................
Nginx — это программное обеспечение с открытым исходным кодом для создания легкого и мощного веб-сервера.
Этот конфигурационный файл Nginx определяет сервер для веб-сайта hhvm-news.tpu.ru на порту 80. Вот что происходит:
1. `listen 80;`: Сервер слушает входящие запросы на порту 80.
2. `server_name hhvm-news.tpu.ru;`: Определяет доменное имя, для которого будет обслуживаться этот сервер.
3. `server_tokens off;`: Отключает отображение версии Nginx в заголовках ответа сервера.
4. `access_log` и `error_log`: Определяют местоположение файлов журналов доступа и ошибок для этого сервера.
5. `root /var/www/news.tpu.ru/html;`: Указывает корневой каталог, где находятся файлы веб-сайта.
6. `index index.php;`: Устанавливает файл index.php в качестве индексного файла.
7. `location / { ... }`: Обрабатывает запросы к корню сайта. Он сначала проверяет наличие запрошенного файла (try_files), 
а если файла нет, то перенаправляет запросы на @rewrite.
8. `location @rewrite { ... }`: Переадресует все запросы (@rewrite) на /index.php.
9. `location ~ \.php$ { ... }`: Обрабатывает запросы к файлам с расширением .php. Он перенаправляет обработку этих запросов на PHP-FPM,
запущенный на localhost:9000, и передает необходимые параметры через fastcgi_param.
10. `location ~* ^.+\.(?:ico|css|js|gif|png|jpe?g)$ { ... }`: Устанавливает кэширование для статических ресурсов, 
таких как иконки, CSS, JavaScript и изображения.
11. `location ~ /\.ht { ... }`: Запрещает доступ к файлам .htaccess.
..................................................................................................
Ansible — система управления конфигурациями, с использованием декларативного языка разметки для описания конфигураций.
1. Инвентарь (Inventory): Инвентарь Ansible - это файл, содержащий информацию о серверах, на которых будет выполняться автоматизация. 
Он может содержать дополнительные данные, такие как переменные хоста, группы хостов и связанные параметры.
2. Плейбуки (Playbooks): Плейбуки Ansible - это файлы, которые описывают задачи, которые необходимо выполнить на определенных хостах 
или группах хостов. Они написаны с использованием YAML-синтаксиса и содержат информацию о том, какие модули Ansible следует использовать 
и какие параметры их настройки.
3. Модули (Modules): Модули Ansible представляют собой самостоятельные скрипты или программы, которые выполняют определенные задачи на хостах. 
Например, модуль apt для управления пакетами в Ubuntu, модуль yum для управления пакетами в CentOS и модуль service для управления службами.
4. Плагины (Plugins): Плагины Ansible расширяют функциональность Ansible и позволяют настраивать его поведение. 
Они могут быть использованы для добавления новых модулей, фильтров, вызовов параметров и других возможностей.
5. Переменные (Variables): Переменные Ansible используются для хранения информации, которая может изменяться в зависимости от условий.
Они могут быть определены на уровне инвентаря, плейбука или группы хостов, и использоваться в плейбуках для установки конфигураций.
6. Шаблоны (Templates): Шаблоны Ansible используются для генерации конфигурационных файлов на основе заданного шаблона. 
Это позволяет параметризировать настройки и передавать различные значения для каждого хоста.
7. Роли (Roles): Роли Ansible используются для определения набора плейбуков, переменных и других файлов,
которые могут быть повторно использованы в различных проектах. Роли позволяют организовать и структурировать 
код Ansible для более удобного управления и масштабирования.
...................................................................................................
Vagrant — свободное и открытое программное обеспечение для создания и конфигурирования виртуальной среды разработки.
Инициализируйте виртуальный проект с помощью команды: vagrant init
Откройте файл Vagrantfile, созданный в папке проекта с помощью любого текстового редактора.
Настройте конфигурацию виртуальной машины в файле Vagrantfile:
ruby
Vagrant.configure("2") do |config|
  config.vm.box = "ubuntu/xenial64"
  config.vm.hostname = "my-vm"
  config.vm.provider "virtualbox" do |vb|
    vb.memory = "1024"
    vb.cpus = 2
  end
vagrant up - создание ВМ
vagrant ssh - подключение к ВМ
...................................................................................................
PostgreSQL — свободная объектно-реляционная система управления базами данных.
PostgreSQL поддерживает несколько методов репликации для обеспечения высокой доступности и отказоустойчивости базы данных. 
Вот пример одного из распространенных методов - поточной репликации (streaming replication):
1. Настройка мастер-сервера:
   - Включите параметр "wal_level" в конфигурационном файле PostgreSQL (например, postgresql.conf) на мастер-сервере, 
   установив его значение на "replica" или "logical".
   - Включите параметр "max_wal_senders" для разрешения подключения slave-серверов.
   - Включите параметр "archive_mode" и укажите директорию для хранения архивных журналов WAL.
2. Создание базы данных реплики:
   - Установите PostgreSQL на slave-сервере.
   - Создайте пустую базу данных на slave-сервере с идентичной конфигурацией и параметрами кодировки, что и на мастер-сервере.
3. Настройка slave-сервера:
   - Включите параметр "hot_standby" и "synchronous_commit" в конфигурационном файле slave-сервера (например, postgresql.conf).
   - Укажите информацию о подключении к мастер-серверу в файле recovery.conf на slave-сервере. 
   Например, укажите параметры "primary_conninfo" и "restore_command" для установления поточного подключения к мастер-серверу 
   и восстановления архивных журналов WAL.
4. Запуск репликации:
   - Запустите мастер-сервер PostgreSQL.
   - Запустите slave-сервер PostgreSQL, и он будет автоматически подключаться к мастер-серверу и начинать репликацию данных.
   - База данных slave-сервера будет обновляться автоматически при изменениях данных на мастер-сервере.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
1. Создание резервной копии базы данных:
- Воспользуйтесь утилитой pg_dump, чтобы создать резервную копию базы данных:
  `pg_dump -U <username> -d <database_name> -F c -f <backup_file>`
- Укажите соответствующие параметры:
  <username>: имя пользователя базы данных
  <database_name>: название базы данных, которую хотите скопировать
  <backup_file>: имя файла для сохранения резервной копии
2. Восстановление базы данных из резервной копии:
- Используйте утилиту pg_restore для восстановления базы данных из резервной копии:
  `pg_restore -U <username> -d <database_name> <backup_file>`
- Укажите соответствующие параметры:
  <username>: имя пользователя базы данных
  <database_name>: название базы данных, в которую хотите восстановить копию
  <backup_file>: имя файла резервной копии, из которой нужно восстановить базу данных
3. Backup и восстановление с помощью инструмента pg_basebackup:
- Для создания физической копии базы данных можно использовать утилиту pg_basebackup:
  `pg_basebackup -U <username> -D <backup_directory>
...................................................................................................
Veeam Backup - это программное обеспечение для резервного копирования данных, предназначенное для виртуальных и физических сред.
1. Запустите консоль Veeam Backup & Replication и выполните вход в систему как администратор.
2. В левой панели навигации выберите "Backup & Replication".
3. Нажмите правой кнопкой мыши на "Backup Jobs" и выберите "Create Backup Job".
4. Введите имя для новой задачи резервного копирования и описание (опционально), затем нажмите "Next".
5. В окне "Virtual machines" выберите виртуальные машины, для которых хотите создать резервные копии, и нажмите "Next".
6. В окне "Storage" выберите устройство хранения, на котором будет создаваться резервная копия. 
Вы можете выбрать локальные диски, сетевые ресурсы или облачные хранилища, а также настроить дополнительные параметры хранения. 
7. В окне "Schedule" выберите опцию "Schedule the backup" и укажите периоды времени, 
когда должны выполняться резервные копии (например, ежедневно, еженедельно). 
Вы также можете установить дополнительные параметры планирования, такие как время начала задания и частоту запуска.
8. В окне "Storage Optimization" установите параметры оптимизации, такие как сжатие данных, дедупликацию и шифрование (при необходимости).
9. На вкладке "Guest processing" можно настроить специфические параметры резервного копирования, например, 
включить создание снимков состояния приложений или выполнение скриптов до или после задачи резервного копирования.
...................................................................................................
Zabbix — свободная система мониторинга статусов разнообразных сервисов компьютерной сети, серверов и сетевого оборудования.
Установите пакет Zabbix Agent с помощью команды:
sudo apt install zabbix-agent
Откройте файл конфигурации Zabbix Agent с помощью текстового редактора, например, nano:
sudo nano /etc/zabbix/zabbix_agentd.conf
Настройте параметры конфигурации Zabbix Agent в файле. Некоторые наиболее распространенные параметры для настройки:
- Server: IP-адрес или доменное имя Zabbix сервера.
- ServerActive: IP-адрес или доменное имя для активного Zabbix сервера (если используется).
- Hostname: уникальное имя для вашего хоста на Zabbix сервере.
- ListenIP: IP-адрес, который Zabbix Agent будет слушать.
- ListenPort: порт, который Zabbix Agent будет слушать.
...................................................................................................
GitLab CI/CD - Процесс состоит из следующих шагов:
Конфигурация: Файл `.gitlab-ci.yml` определяет и описывает этапы и задачи для CI/CD процесса.
Пайплайн: После каждого коммита в GitLab, происходит запуск CI/CD процесса в рамках пайплайна.
Этапы: Пайплайн состоит из различных этапов, которые могут быть определены в файле `.gitlab-ci.yml`.
Этапы могут включать задачи по сборке, тестированию, а также задачи определенные пользователем.
Задачи (jobs): В рамках каждого этапа определяются задачи (jobs) для выполнения. Каждая задача выполняется в 
отдельном контейнере или виртуальной машине, и может быть настроена для выполнения определенных шагов, таких как сборка, 
тестирование или развертывание.
(Хранилки артифактов Nexus) Артифакты: После выполнения каждой задачи, могут быть сохранены артифакты, для использования в последующих задачах 
Развертывание: По завершении CI/CD процесса, GitLab CI/CD может автоматически развернуть ваше приложение в выбранную целевую среду 

Основные моменты в gitlab ci:
image - выбор образа, которую будем использовать для сборки и развертывания проекта;
services - описание сервисов, запущенных во время выполнения pipeline, в данном случае для запуска контейнеров используется docker:dind;
variables - объявление переменных, которые используются для настройки среды выполнения GitLab CI/CD, такие как настройка драйвера Docker, 
хоста Docker, тега Docker-образа, используемого в рамках pipeline, и прочее;
stages - описание этапов сборки, тестирования и развертывания проекта в GitLab, используемых в pipeline. 
Основные этапы, через которые проходит код:
build - этап сборки приложения и связанных с ним контейнеров или бинарных файлов;
test - этап тестирования приложения. Он может включать в себя юнит-тестирование, функциональное тестирование и интеграционное тестирование;
deploy - этап развертывания приложения. В этом этапе приложение развёртывается на указанной инфраструктуре, например, на серверах или 
в Kubernetes кластере;
package – этап в GitLab CI/CD пайплайне выполняет задачу упаковки или создания пакета приложения, который можно развернуть где-то еще;
before_script - определяет скрипт, который должен быть выполнен перед запуском всех заданий в pipeline. Здесь выполняется авторизация в 
Docker Registry, используемом для хранения контейнеров и образов. 
Вебхуки - пуш модель которая отправляет от гита в ci/cd инструменты федбеки
...................................................................................................

